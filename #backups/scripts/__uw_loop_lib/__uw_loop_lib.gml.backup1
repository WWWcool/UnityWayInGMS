// 2021-03-27 22:05:14
// Unity way library. For more information see the documentation here:
// https://github.com/WWWcool/UnityWayInGMS/wiki


function UWDelegate(_size) constructor
{
    stack = [];
    limit = (_size == undefined ? infinity : _size);
    bind = undefined;
    
    static Bind = function(_instance_or_struct) 
    {
        if(!is_struct(_instance_or_struct))
        {
            if(!instance_exists(_instance_or_struct)) 
            {
                if(!is_undefined(_instance_or_struct))
                {
                    var error = new UWUtilsError();
                    error.SetType(self);
                    error.AddText("Нельзя привязатель делегат к не существующему объекту: ", _instance_or_struct);
                    error.Show();
                }
                bind = undefined;
                return self;
            }
        }
        bind = _instance_or_struct;
        return self;
    }
    
    static IsFree = function() 
    {
        return (array_length(stack) < limit);
    }
    
    static Add = function(_method_or_function, _argument)
    {
        if(!IsFree()) return false;
        
        if(is_method(_method_or_function)) 
            _method_or_function = method_get_index(_method_or_function);
        
        var _cell =
        {
            execute: _method_or_function,
            argument: _argument
        }
        
        array_push(stack, _cell);
        return true;
    }
    
    static Run = function() 
    {
        var _size = array_length(stack);
        if(_size) {
            var _context = bind;
            
            if(argument_count > 0)
                _context = argument[0];
            
            if(!is_struct(_context))
            {
                if(!instance_exists(_context)) 
                    UWDelegateError(_context);
                
                if(_context == undefined) 
                    _context = other;
            }
            
            with _context 
            {
                var _i = 0, _cell;
                do
                {
                    _cell = stack[_i];
                    _cell.execute(_cell.argument);
                } until (++_i == _size);
            }
        }
        return self;
    }
    
    static Clear = function()
    {
        stack = [];
    }
    
    static RemoveFromBegin = function(_count)
    {
        
    }
    
    static RemoveFromEnd = function(_count)
    {
        
    }
    
    static LimitResize = function(_newsize) 
    {
        
    }
    
}
